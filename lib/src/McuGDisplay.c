/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : McuGDisplay.c
**     Project     : FRDM-K64F_Generator
**     Processor   : MK64FN1M0VLL12
**     Component   : GDisplay
**     Version     : Component 01.197, Driver 01.00, CPU db: 3.00.000
**     Repository  : Legacy User Components
**     Compiler    : GNU C Compiler
**     Date/Time   : 2017-11-30, 19:13, # CodeGen: 251
**     Abstract    :
**
**     Settings    :
**          Component name                                 : McuGDisplay
**          SDK                                            : McuLib
**          Inverted Pixels                                : no
**          Memory Buffer                                  : Enabled
**            Orientation                                  : Landscape
**          Clear screen on Init                           : no
**          Hardware                                       : 
**            Display                                      : McuSharpMemoryDisplay
**          Watchdog                                       : Disabled
**          RTOS                                           : Disabled
**     Contents    :
**         PutPixel          - void McuGDisplay_PutPixel(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y,...
**         SetPixel          - void McuGDisplay_SetPixel(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y);
**         ClrPixel          - void McuGDisplay_ClrPixel(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y);
**         Clear             - void McuGDisplay_Clear(void);
**         DrawBox           - void McuGDisplay_DrawBox(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y,...
**         DrawFilledBox     - void McuGDisplay_DrawFilledBox(McuGDisplay_PixelDim x, McuGDisplay_PixelDim...
**         DrawHLine         - void McuGDisplay_DrawHLine(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y,...
**         DrawVLine         - void McuGDisplay_DrawVLine(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y,...
**         DrawLine          - void McuGDisplay_DrawLine(McuGDisplay_PixelDim xstart, McuGDisplay_PixelDim...
**         DrawCircle        - void McuGDisplay_DrawCircle(McuGDisplay_PixelDim x0, McuGDisplay_PixelDim y0,...
**         DrawFilledCircle  - void McuGDisplay_DrawFilledCircle(McuGDisplay_PixelDim x0,...
**         DrawBarChart      - void McuGDisplay_DrawBarChart(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y,...
**         DrawMonoBitmap    - void McuGDisplay_DrawMonoBitmap(McuGDisplay_PixelDim x, McuGDisplay_PixelDim...
**         DrawColorBitmap   - void McuGDisplay_DrawColorBitmap(McuGDisplay_PixelDim x, McuGDisplay_PixelDim...
**         Draw65kBitmap     - void McuGDisplay_Draw65kBitmap(McuGDisplay_PixelDim x1, McuGDisplay_PixelDim...
**         Draw256BitmapLow  - void McuGDisplay_Draw256BitmapLow(McuGDisplay_PixelDim x1,...
**         Draw256BitmapHigh - void McuGDisplay_Draw256BitmapHigh(McuGDisplay_PixelDim x1,...
**         UpdateFull        - void McuGDisplay_UpdateFull(void);
**         UpdateRegion      - void McuGDisplay_UpdateRegion(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y,...
**         GetWidth          - McuGDisplay_PixelDim McuGDisplay_GetWidth(void);
**         GetHeight         - McuGDisplay_PixelDim McuGDisplay_GetHeight(void);
**         GetLongerSide     - McuGDisplay_PixelDim McuGDisplay_GetLongerSide(void);
**         GetShorterSide    - McuGDisplay_PixelDim McuGDisplay_GetShorterSide(void);
**         GetDisplay        - void McuGDisplay_GetDisplay(void);
**         GiveDisplay       - void McuGDisplay_GiveDisplay(void);
**         Init              - void McuGDisplay_Init(void);
**
**     * Copyright (c) 2013-2017, Erich Styger
**      * Web:         https://mcuoneclipse.com
**      * SourceForge: https://sourceforge.net/projects/mcuoneclipse
**      * Git:         https://github.com/ErichStyger/McuOnEclipse_PEx
**      * All rights reserved.
**      *
**      * Redistribution and use in source and binary forms, with or without modification,
**      * are permitted provided that the following conditions are met:
**      *
**      * - Redistributions of source code must retain the above copyright notice, this list
**      *   of conditions and the following disclaimer.
**      *
**      * - Redistributions in binary form must reproduce the above copyright notice, this
**      *   list of conditions and the following disclaimer in the documentation and/or
**      *   other materials provided with the distribution.
**      *
**      * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**      * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**      * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**      * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**      * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**      * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**      * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**      * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**      * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
** ###################################################################*/
/*!
** @file McuGDisplay.c
** @version 01.00
** @brief
**
*/         
/*!
**  @addtogroup McuGDisplay_module McuGDisplay module documentation
**  @{
*/         

/* MODULE McuGDisplay. */

#include "McuGDisplay.h"

static const word c332to565[256] = { /* converts a 3-3-2 RBG value into a 5-6-5 RGB value */
 0x0000, 0x000A, 0x0014, 0xF81E, 0x0120, 0x012A, 0x0134, 0xF93E,
 0x0240, 0x024A, 0x0254, 0xFA5E, 0x0360, 0x036A, 0x0374, 0xFB7E,
 0x0480, 0x048A, 0x0494, 0xFC9E, 0x05A0, 0x05AA, 0x05B4, 0xFDBE,
 0x06C0, 0x06CA, 0x06D4, 0xFEDE, 0x07E0, 0x07EA, 0x07F4, 0xFFFE,
 0x2000, 0x200A, 0x2014, 0xF81E, 0x2120, 0x212A, 0x2134, 0xF93E,
 0x2240, 0x224A, 0x2254, 0xFA5E, 0x2360, 0x236A, 0x2374, 0xFB7E,
 0x2480, 0x248A, 0x2494, 0xFC9E, 0x25A0, 0x25AA, 0x25B4, 0xFDBE,
 0x26C0, 0x26CA, 0x26D4, 0xFEDE, 0x27E0, 0x27EA, 0x27F4, 0xFFFE,
 0x4000, 0x400A, 0x4014, 0xF81E, 0x4120, 0x412A, 0x4134, 0xF93E,
 0x4240, 0x424A, 0x4254, 0xFA5E, 0x4360, 0x436A, 0x4374, 0xFB7E,
 0x4480, 0x448A, 0x4494, 0xFC9E, 0x45A0, 0x45AA, 0x45B4, 0xFDBE,
 0x46C0, 0x46CA, 0x46D4, 0xFEDE, 0x47E0, 0x47EA, 0x47F4, 0xFFFE,
 0x6000, 0x600A, 0x6014, 0xF81E, 0x6120, 0x612A, 0x6134, 0xF93E,
 0x6240, 0x624A, 0x6254, 0xFA5E, 0x6360, 0x636A, 0x6374, 0xFB7E,
 0x6480, 0x648A, 0x6494, 0xFC9E, 0x65A0, 0x65AA, 0x65B4, 0xFDBE,
 0x66C0, 0x66CA, 0x66D4, 0xFEDE, 0x67E0, 0x67EA, 0x67F4, 0xFFFE,
 0x8000, 0x800A, 0x8014, 0xF81E, 0x8120, 0x812A, 0x8134, 0xF93E,
 0x8240, 0x824A, 0x8254, 0xFA5E, 0x8360, 0x836A, 0x8374, 0xFB7E,
 0x8480, 0x848A, 0x8494, 0xFC9E, 0x85A0, 0x85AA, 0x85B4, 0xFDBE,
 0x86C0, 0x86CA, 0x86D4, 0xFEDE, 0x87E0, 0x87EA, 0x87F4, 0xFFFE,
 0xA000, 0xA00A, 0xA014, 0xF81E, 0xA120, 0xA12A, 0xA134, 0xF93E,
 0xA240, 0xA24A, 0xA254, 0xFA5E, 0xA360, 0xA36A, 0xA374, 0xFB7E,
 0xA480, 0xA48A, 0xA494, 0xFC9E, 0xA5A0, 0xA5AA, 0xA5B4, 0xFDBE,
 0xA6C0, 0xA6CA, 0xA6D4, 0xFEDE, 0xA7E0, 0xA7EA, 0xA7F4, 0xFFFE,
 0xC000, 0xC00A, 0xC014, 0xF81E, 0xC120, 0xC12A, 0xC134, 0xF93E,
 0xC240, 0xC24A, 0xC254, 0xFA5E, 0xC360, 0xC36A, 0xC374, 0xFB7E,
 0xC480, 0xC48A, 0xC494, 0xFC9E, 0xC5A0, 0xC5AA, 0xC5B4, 0xFDBE,
 0xC6C0, 0xC6CA, 0xC6D4, 0xFEDE, 0xC7E0, 0xC7EA, 0xC7F4, 0xFFFE,
 0xF800, 0xF80A, 0xF814, 0xF81E, 0xF920, 0xF92A, 0xF934, 0xF93E,
 0xFA40, 0xFA4A, 0xFA54, 0xFA5E, 0xFB60, 0xFB6A, 0xFB74, 0xFB7E,
 0xFC80, 0xFC8A, 0xFC94, 0xFC9E, 0xFDA0, 0xFDAA, 0xFDB4, 0xFDBE,
 0xFEC0, 0xFECA, 0xFED4, 0xFEDE, 0xFFE0, 0xFFEA, 0xFFF4, 0xFFFE,
};
/*
** ===================================================================
**     Method      :  McuGDisplay_Clear (component GDisplay)
**     Description :
**         Clears the display buffer.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_Clear(void)
{
  uint8_t *p = (uint8_t*)(&McuSharpMemoryDisplay_DisplayBuf[0][0]); /* first element in display buffer */

  while (p<((byte*)McuSharpMemoryDisplay_DisplayBuf)+sizeof(McuSharpMemoryDisplay_DisplayBuf)) {
 #if McuGDisplay_CONFIG_NOF_BITS_PER_PIXEL==1
    *p++ = (byte)(  (McuGDisplay_COLOR_WHITE<<7)
                  | (McuGDisplay_COLOR_WHITE<<6)
                  | (McuGDisplay_COLOR_WHITE<<5)
                  | (McuGDisplay_COLOR_WHITE<<4)
                  | (McuGDisplay_COLOR_WHITE<<3)
                  | (McuGDisplay_COLOR_WHITE<<2)
                  | (McuGDisplay_COLOR_WHITE<<1)
                  |  McuGDisplay_COLOR_WHITE
                 );
 #elif McuGDisplay_CONFIG_NOF_BITS_PER_PIXEL==16
    *((uint16_t*)p) = McuGDisplay_COLOR_WHITE;
    p += 2;
 #else
    *p++ = McuGDisplay_COLOR_WHITE;
 #endif
  }
}

/*
** ===================================================================
**     Method      :  McuGDisplay_SetPixel (component GDisplay)
**     Description :
**         Sets a pixel in the display buffer
**     Parameters  :
**         NAME            - DESCRIPTION
**         x               - Pixel x position
**         y               - Pixel y position
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_SetPixel(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y)
{
  if (x>=McuGDisplay_GetWidth() || y>=McuGDisplay_GetHeight()) { /* values out of range */
    return;
  }
#if McuGDisplay_CONFIG_USE_WINDOW_CAPABILITY
  McuGDisplay_CONFIG_FCT_NAME_OPENWINDOW(x, y, x, y); /* set up a one pixel window */
  McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(McuGDisplay_COLOR_BLACK); /* store pixel with color information */
  McuGDisplay_CONFIG_FCT_NAME_CLOSEWINDOW(); /* close and execute window */
#elif McuGDisplay_CONFIG_USE_DISPLAY_MEMORY_WRITE
  McuGDisplay_CONFIG_FCT_NAME_SETPIXEL(x, y);
#elif McuGDisplay_CONFIG_NOF_BITS_PER_PIXEL==16
  McuGDisplay_BUF_WORD(x,y) = McuGDisplay_COLOR_BLACK;
#else
  McuGDisplay_BUF_BYTE(x,y) |= McuGDisplay_BUF_BYTE_PIXEL_MASK(x,y);
#endif
}

/*
** ===================================================================
**     Method      :  McuGDisplay_ClrPixel (component GDisplay)
**     Description :
**         Clears a single pixel in the display.
**     Parameters  :
**         NAME            - DESCRIPTION
**         x               - Pixel x position.
**         y               - Pixel y position.
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_ClrPixel(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y)
{
  if (x>=McuGDisplay_GetWidth() || y>=McuGDisplay_GetHeight()) { /* values out of range */
    return;
  }
#if McuGDisplay_CONFIG_USE_WINDOW_CAPABILITY
  McuGDisplay_CONFIG_FCT_NAME_OPENWINDOW(x, y, x, y); /* set up a one pixel window */
  McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(McuGDisplay_COLOR_WHITE); /* store pixel with color information */
  McuGDisplay_CONFIG_FCT_NAME_CLOSEWINDOW(); /* close and execute window */
#elif McuGDisplay_CONFIG_USE_DISPLAY_MEMORY_WRITE
  McuSharpMemoryDisplay_ClrPixel(x, y);
#elif McuGDisplay_CONFIG_NOF_BITS_PER_PIXEL==16
  McuGDisplay_BUF_WORD(x,y) = McuGDisplay_COLOR_WHITE;
#else
  McuGDisplay_BUF_BYTE(x,y) &= ~McuGDisplay_BUF_BYTE_PIXEL_MASK(x,y);
#endif
}

/*
** ===================================================================
**     Method      :  McuGDisplay_UpdateFull (component GDisplay)
**     Description :
**         Updates the image on the display. This is needed in case the
**         display requires a periodic refresh. For display using
**         windowing, this function may be implemented as dummy stub,
**         as the display content already is written.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
/* method is implemented as macro in header file
void McuGDisplay_UpdateFull(void)
{
}
*/

/*
** ===================================================================
**     Method      :  McuGDisplay_PutPixel (component GDisplay)
**     Description :
**         
**     Parameters  :
**         NAME            - DESCRIPTION
**         x               - x coordinate
**         y               - y coordinate
**         color           - color to be used for the pixel
**     Returns     : Nothing
** ===================================================================
*/
#ifdef __HC08__
  #pragma MESSAGE DISABLE C4001 /* condition always FALSE */
#endif
void McuGDisplay_PutPixel(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y, McuGDisplay_PixelColor color)
{
  if (x>=McuGDisplay_GetWidth() || y>=McuGDisplay_GetHeight()) { /* values out of range */
    return;
  }
#if McuGDisplay_CONFIG_USE_WINDOW_CAPABILITY
  McuGDisplay_CONFIG_FCT_NAME_OPENWINDOW(x, y, x, y); /* set up window as large as the box */
  McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(color); /* store pixel with color information */
  McuGDisplay_CONFIG_FCT_NAME_CLOSEWINDOW(); /* close and execute window */
#else
 #if McuGDisplay_CONFIG_NOF_BITS_PER_PIXEL==1
  if (   (color==McuGDisplay_COLOR_BLACK && McuGDisplay_COLOR_BLACK==McuGDisplay_COLOR_PIXEL_SET)
      || (color==McuGDisplay_COLOR_WHITE && McuGDisplay_COLOR_WHITE==McuGDisplay_COLOR_PIXEL_SET)
     )
  {
    McuGDisplay_SetPixel(x,y);
  } else {
    McuGDisplay_ClrPixel(x,y);
  }
 #elif McuGDisplay_CONFIG_NOF_BITS_PER_PIXEL==16
  McuGDisplay_BUF_WORD(x,y) = color;
 #else /* multi-bit display */
  McuSharpMemoryDisplay_PutPixel(x, y, color);
 #endif
#endif
}
#ifdef __HC08__
  #pragma MESSAGE DEFAULT C4001 /* condition always FALSE */
#endif

/*
** ===================================================================
**     Method      :  McuGDisplay_DrawFilledBox (component GDisplay)
**     Description :
**         Draws a rectangle box (filled)
**     Parameters  :
**         NAME            - DESCRIPTION
**         x               - x left upper coordinate
**         y               - y left upper coordinate
**         width           - Width in pixels
**         height          - Height in pixels
**         color           - color to be used to fill the box.
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_DrawFilledBox(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y, McuGDisplay_PixelDim width, McuGDisplay_PixelDim height, McuGDisplay_PixelColor color)
{
#if McuGDisplay_CONFIG_USE_WINDOW_CAPABILITY
  McuGDisplay_PixelCount pixCnt;
  McuGDisplay_PixelDim x1, y1;
#else
  McuGDisplay_PixelDim x0, xe, y0, ye;
#endif
  McuGDisplay_PixelDim d_width = McuGDisplay_GetWidth();
  McuGDisplay_PixelDim d_height = McuGDisplay_GetHeight();

  if (   width==0 || height==0
      || x>=d_width || y>=d_height
     ) {
    return; /* nothing to do */
  }
  if (x+width>d_width) { /* value out of range */
    if (x>=d_width) {
      return;                          /* completely outside of display */
    } else {
      width = (McuGDisplay_PixelDim)(d_width-x);
    }
  }
  if (y+height>d_height) { /* value out of range */
    if (y>=d_height) {
      return;                          /* completely outside of display */
    } else {
      height = (McuGDisplay_PixelDim)(d_height-y);
    }
  }
#if McuGDisplay_CONFIG_USE_WINDOW_CAPABILITY
  x1 = (McuGDisplay_PixelDim)(x+width-1); /* set window lower right x coordinate */
  y1 = (McuGDisplay_PixelDim)(y+height-1); /* set window lower right y coordinate */
  pixCnt = (McuGDisplay_PixelCount)((x1-x+1)*(y1-y+1)); /* number of pixels to write */
  McuGDisplay_CONFIG_FCT_NAME_OPENWINDOW(x, y, x1, y1); /* set up window as large as the box */
  while (pixCnt>0) {
    McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(color); /* store pixel with color information */
    pixCnt--;
  } /* while */
  McuGDisplay_CONFIG_FCT_NAME_CLOSEWINDOW(); /* close and execute window */
#else
  y0 = y; ye = (McuGDisplay_PixelDim)(y0+height-1);
  for(;;) { /* breaks */
    x0 = x; xe = (McuGDisplay_PixelDim)(x0+width-1);
    for(;;) { /* process line, breaks */
      McuGDisplay_PutPixel(x0, y0, color);
      if (x0==xe) {
        break; /* reached end of line */
      }
      x0++;
    } /* for */
    if (y0==ye) {
      break; /* reached end */
    }
    y0++;
  } /* for */
#endif
}

/*
** ===================================================================
**     Method      :  McuGDisplay_DrawBox (component GDisplay)
**     Description :
**         Draws a rectangle line box
**     Parameters  :
**         NAME            - DESCRIPTION
**         x               - x left upper coordinate
**         y               - y left upper coordinate
**         width           - width in pixels
**         height          - height in pixels
**         lineWidth       - width of the line
**         color           - color for the box
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_DrawBox(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y, McuGDisplay_PixelDim width, McuGDisplay_PixelDim height, McuGDisplay_PixelDim lineWidth, McuGDisplay_PixelColor color)
{
  /* top line: */
  McuGDisplay_DrawFilledBox(x, y, width, lineWidth, color);
  /* left line: */
  McuGDisplay_DrawFilledBox(x, (McuGDisplay_PixelDim)(y+lineWidth), lineWidth, (McuGDisplay_PixelDim)(height-(2*lineWidth)), color);
  /* right line: */
  McuGDisplay_DrawFilledBox((McuGDisplay_PixelDim)(x+width-lineWidth), (McuGDisplay_PixelDim)(y+lineWidth), lineWidth, (McuGDisplay_PixelDim)(height-(2*lineWidth)), color);
  /* bottom line: */
  McuGDisplay_DrawFilledBox(x, (McuGDisplay_PixelDim)(y+height-lineWidth), width, lineWidth, color);
}

/*
** ===================================================================
**     Method      :  McuGDisplay_DrawMonoBitmap (component GDisplay)
**     Description :
**         Draws a B/W bitmap.
**     Parameters  :
**         NAME            - DESCRIPTION
**         x               - x position of left upper corner
**         y               - y position of left upper corner
**         image           - Pointer to image structure and
**                           information.
**         pixelColor      - Color to be used for pixels
**                           (pixel set)
**         backgroundColor - Color to be used
**                           for background (pixel not set)
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_DrawMonoBitmap(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y, PIMAGE image, McuGDisplay_PixelColor pixelColor, McuGDisplay_PixelColor backgroundColor)
{
  McuGDisplay_PixelDim x0, y0, xe, ye;
  McuGDisplay_PixelColor pixel;
  byte i;
  const byte *data;

  data = image->pixmap;
  y0 = y;
  ye = (McuGDisplay_PixelDim)(y+image->height-1);
  xe = (McuGDisplay_PixelDim)(x+image->width-1);
  for(;;) {
    i=7;
    x0 = x;
    for(;;) {
      pixel = (McuGDisplay_PixelColor)(((*data)&(1<<i))>>i); /* extract pixel out of bitstream */
      McuGDisplay_PutPixel(x0, y0, (McuGDisplay_PixelColor)(pixel==1?pixelColor:backgroundColor));
      if (i==0 && x0!=xe) { /* next byte inside the row */
        data++;
        i = 7;
      } else {
        i--;
      }
      if (x0==xe) { /* reached end of line, next row */
        data++; /* next data byte */
        break;
      }
      x0++;
    } /* for */
    if (y0==ye) break; /* reached end */
    y0++;
  } /* for */
}

/*
** ===================================================================
**     Method      :  McuGDisplay_DrawColorBitmap (component GDisplay)
**     Description :
**         Draws a color bitmap. Pixel data is in 3-3-2 RGB format.
**     Parameters  :
**         NAME            - DESCRIPTION
**         x               - x position of left upper corner
**         y               - y position of left upper corner
**         image           - Pointer to image structure and
**                           information.
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_DrawColorBitmap(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y, PIMAGE image)
{
  McuGDisplay_PixelDim x0, y0, xe, ye;
  McuGDisplay_PixelColor pixel;
  const byte *data;

  data = image->pixmap;
  y0 = y;
  ye = (McuGDisplay_PixelDim)(y+image->height-1);
  xe = (McuGDisplay_PixelDim)(x+image->width-1);
  for(;;) {
    x0 = x;
    for(;;) {
      pixel = (McuGDisplay_PixelColor)c332to565[*data]; /* extract pixel out of bitstream and convert it to our color mode*/
      McuGDisplay_PutPixel(x0, y0, pixel);
      data++;
      if (x0==xe) { /* reached end of line, next row */
        break;
      }
      x0++;
    } /* for */
    if (y0==ye) break; /* reached end */
    y0++;
  } /* for */
}

/*
** ===================================================================
**     Method      :  McuGDisplay_DrawHLine (component GDisplay)
**     Description :
**         Draws a horizontal line
**     Parameters  :
**         NAME            - DESCRIPTION
**         x               - x left upper coordinate
**         y               - y left upper coordinate
**         length          - Length of line in pixels
**         color           - color to be used to fill the box.
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_DrawHLine(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y, McuGDisplay_PixelDim length, McuGDisplay_PixelColor color)
{
  McuGDisplay_DrawFilledBox(x, y, length, 1, color);
}

/*
** ===================================================================
**     Method      :  McuGDisplay_DrawVLine (component GDisplay)
**     Description :
**         Draws a vertical line
**     Parameters  :
**         NAME            - DESCRIPTION
**         x               - x left upper coordinate
**         y               - y left upper coordinate
**         length          - Length of line in pixels
**         color           - color to be used to fill the box.
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_DrawVLine(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y, McuGDisplay_PixelDim length, McuGDisplay_PixelColor color)
{
  McuGDisplay_DrawFilledBox(x, y, 1, length, color);
}

/*
** ===================================================================
**     Method      :  McuGDisplay_DrawBarChart (component GDisplay)
**     Description :
**         Draws a series of bars for a chart
**     Parameters  :
**         NAME            - DESCRIPTION
**         x               - upper left corner x coordinate
**         y               - upper left corner y coordinate
**         width           - Chart box width
**         height          - Chart box height
**       * data            - Pointer to data (series of % values
**                           from 0...100%)
**         nofData         - number of data bytes
**         barColor        - Color to be used for the bars.
**         borderWidth     - width of a border to be
**                           draw. Pass zero if there shall be no border.
**         borderColor     - Color to be used for the
**                           border (if borderWidth is not zero)
**         borderSpace     - Space to be used in pixels
**                           between border and bars.
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_DrawBarChart(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y, McuGDisplay_PixelDim width, McuGDisplay_PixelDim height, byte *data, byte nofData, McuGDisplay_PixelColor barColor, byte borderWidth, McuGDisplay_PixelColor borderColor, byte borderSpace)
{
  uint8_t i;
  McuGDisplay_PixelDim barHeight; /* for calculation of each bar height */
  McuGDisplay_PixelDim barWidth; /* bar width, based on even distribution of the bars */

  if (borderWidth > 0) { /* border */
    McuGDisplay_DrawBox(x, y, width, height, borderWidth, borderColor);
  }
  /* reduce drawing area because of border */
  x += borderWidth+borderSpace;
  y += borderWidth+borderSpace;
  width -= 2*(borderWidth+borderSpace);
  height -= 2*(borderWidth+borderSpace);

  /* calculat bar width based on number of bars so we fill out our drawing area */
  barWidth = (McuGDisplay_PixelDim)((width-(nofData+1)*borderSpace)/nofData);

  /* draw some bars */
  for(i=0; i<nofData; i++) {
    barHeight = (McuGDisplay_PixelDim)((height*data[i])/100); /* scale with % value */
    if (barHeight > 0) {
      McuGDisplay_DrawFilledBox(x, (McuGDisplay_PixelDim)(y+height-barHeight), barWidth, barHeight, barColor);
    }
    x += barWidth+borderSpace;
  }
}

/*
** ===================================================================
**     Method      :  McuGDisplay_DrawLine (component GDisplay)
**     Description :
**         Draws a line using the Bresenham method
**     Parameters  :
**         NAME            - DESCRIPTION
**         xstart          - x start coordinate
**         ystart          - y start coordinate
**         xend            - x end coordinate
**         yend            - y end coordinate
**         color           - color to be used for the line
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_DrawLine(McuGDisplay_PixelDim xstart, McuGDisplay_PixelDim ystart, McuGDisplay_PixelDim xend, McuGDisplay_PixelDim yend, McuGDisplay_PixelColor color)
{
  /* Based on Bresenham algorithm and http://de.wikipedia.org/wiki/Bresenham-Algorithmus */
  #define sgn(x) ((x) > 0) ? 1 : ((x) < 0) ? -1 : 0
  McuGDisplay_PixelDim x, y;
  int t, dx, dy, incx, incy, pdx, pdy, ddx, ddy, es, el, err;

  /* Calculate distance in both dimensions */
  dx = xend - xstart;
  dy = yend - ystart;
  /* Determin sign of increment */
  incx = sgn(dx);
  incy = sgn(dy);
  if(dx<0) dx = -dx;
  if(dy<0) dy = -dy;
  /* Check which distance is larger */
  if (dx>dy) { /* we are faster in x direction */
    pdx=incx; pdy=0;    /* pd. is parallel step */
    ddx=incx; ddy=incy; /* dd. is diagonal step */
    es =dy;   el =dx;   /* error steps fast (es) and slow (el) */
  } else { /* faster in y direction */
    pdx=0;    pdy=incy; /* pd. is parallel step */
    ddx=incx; ddy=incy; /* dd. is diagonal step */
    es =dx;   el =dy;   /* error step fast (es) and slow (el) */
  }
  /* Do some initialization first... */
  x = xstart; y = ystart; err = el/2;
  McuGDisplay_PutPixel(x, y, color); /* put first pixel */
  /* calculate pixels */
  for(t=0; t<el; ++t) { /* t counts the pixels, el is the number of pixels */
    err -= es; /* adapt error */
    if(err<0) { /* make error positive again */
      err += el;
      /* step into the slow direction, diagonal step  */
      x += ddx;
      y += ddy;
    } else {
      /* step into the fast direction, parallel step*/
      x += pdx;
      y += pdy;
    }
    McuGDisplay_PutPixel(x, y, color);
  }
}

/*
** ===================================================================
**     Method      :  McuGDisplay_DrawCircle (component GDisplay)
**     Description :
**         Draws a circle using the Bresenham method
**     Parameters  :
**         NAME            - DESCRIPTION
**         x0              - x start coordinate
**         y0              - y start coordinate
**         radius          - Radius of the circle
**         color           - color to be used for the line
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_DrawCircle(McuGDisplay_PixelDim x0, McuGDisplay_PixelDim y0, McuGDisplay_PixelDim radius, McuGDisplay_PixelColor color)
{
  /* draw a circle using the Bresenham method, see http://de.wikipedia.org/wiki/Bresenham-Algorithmus */
  int f = 1 - radius;
  int ddF_x = 0;
  int ddF_y = -2 * radius;
  McuGDisplay_PixelDim x = 0;
  McuGDisplay_PixelDim y = radius;

  McuGDisplay_PutPixel(x0, (McuGDisplay_PixelDim)(y0 + radius), color);
  McuGDisplay_PutPixel(x0, (McuGDisplay_PixelDim)(y0 - radius), color);
  McuGDisplay_PutPixel((McuGDisplay_PixelDim)(x0 + radius), y0, color);
  McuGDisplay_PutPixel((McuGDisplay_PixelDim)(x0 - radius), y0, color);
  while(x < y) {
    if(f >= 0) {
      y--;
      ddF_y += 2;
      f += ddF_y;
    }
    x++;
    ddF_x += 2;
    f += ddF_x + 1;
    McuGDisplay_PutPixel((McuGDisplay_PixelDim)(x0 + x), (McuGDisplay_PixelDim)(y0 + y), color);
    McuGDisplay_PutPixel((McuGDisplay_PixelDim)(x0 - x), (McuGDisplay_PixelDim)(y0 + y), color);
    McuGDisplay_PutPixel((McuGDisplay_PixelDim)(x0 + x), (McuGDisplay_PixelDim)(y0 - y), color);
    McuGDisplay_PutPixel((McuGDisplay_PixelDim)(x0 - x), (McuGDisplay_PixelDim)(y0 - y), color);
    McuGDisplay_PutPixel((McuGDisplay_PixelDim)(x0 + y), (McuGDisplay_PixelDim)(y0 + x), color);
    McuGDisplay_PutPixel((McuGDisplay_PixelDim)(x0 - y), (McuGDisplay_PixelDim)(y0 + x), color);
    McuGDisplay_PutPixel((McuGDisplay_PixelDim)(x0 + y), (McuGDisplay_PixelDim)(y0 - x), color);
    McuGDisplay_PutPixel((McuGDisplay_PixelDim)(x0 - y), (McuGDisplay_PixelDim)(y0 - x), color);
  }
}

/*
** ===================================================================
**     Method      :  McuGDisplay_DrawFilledCircle (component GDisplay)
**     Description :
**         Draws a circle using the Bresenham method
**     Parameters  :
**         NAME            - DESCRIPTION
**         x0              - x start coordinate
**         y0              - y start coordinate
**         radius          - Radius of the circle
**         color           - fill color to be used
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_DrawFilledCircle(McuGDisplay_PixelDim x0, McuGDisplay_PixelDim y0, McuGDisplay_PixelDim radius, McuGDisplay_PixelColor color)
{
  /* draw a circle using the Bresenham method, see http://de.wikipedia.org/wiki/Bresenham-Algorithmus and
  http://forums.tigsource.com/index.php?topic=17068.0;wap2 */
  McuGDisplay_PixelDim xoff=0;
  McuGDisplay_PixelDim yoff=radius;
  int balance=-((int)radius);
  McuGDisplay_PixelDim p0, p1, w0, w1;

  while (xoff <= yoff) {
    p0 = (McuGDisplay_PixelDim)(x0-xoff);
    p1 = (McuGDisplay_PixelDim)(x0-yoff);
    w0 = (McuGDisplay_PixelDim)(2*xoff);
    w1 = (McuGDisplay_PixelDim)(2*yoff);
    McuGDisplay_DrawHLine(p0, (McuGDisplay_PixelDim)(y0+yoff), w0, color);
    McuGDisplay_DrawHLine(p0, (McuGDisplay_PixelDim)(y0-yoff), w0, color);
    McuGDisplay_DrawHLine(p1, (McuGDisplay_PixelDim)(y0+xoff), w1, color);
    McuGDisplay_DrawHLine(p1, (McuGDisplay_PixelDim)(y0-xoff), w1, color);
    balance += 2*xoff;
    xoff++;
    if (balance>=0) {
      yoff--;
      balance -= 2*yoff;
    }
  } /* while */
}

/*
** ===================================================================
**     Method      :  McuGDisplay_Draw65kBitmap (component GDisplay)
**     Description :
**         Draws a 65k color bitmap (compressed or uncompressed)
**     Parameters  :
**         NAME            - DESCRIPTION
**         x1              - left upper starting corner
**         y1              - left upper starting corner
**         x2              - right lower corner
**         y2              - right lower corner
**       * bmp             - Pointer to bitmap
**         compressed      - 
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_Draw65kBitmap(McuGDisplay_PixelDim x1, McuGDisplay_PixelDim y1, McuGDisplay_PixelDim x2, McuGDisplay_PixelDim y2, word *bmp, bool compressed)
{
#if McuGDisplay_CONFIG_USE_WINDOW_CAPABILITY
  McuGDisplay_PixelCount pixelCount = (McuGDisplay_PixelCount)((x2-x1+1) * (y2-y1+1));

#endif
#if McuGDisplay_CONFIG_USE_WINDOW_CAPABILITY
  McuGDisplay_CONFIG_FCT_NAME_OPENWINDOW(x1, y1, x2, y2); /* set up window as large as the box */
  if (compressed) {
    McuGDisplay_PixelColor PixelColor = 0;
    uint16_t Pos = 0;
    bool FirstRead = TRUE;
    uint16_t i;
    uint16_t Repeat;

    for (i=0; i<pixelCount; i++) {
      if (FirstRead) {                  /* read first pixel after first start or after finishing a compressed bunch of data */
        PixelColor = (McuGDisplay_PixelColor)bmp[Pos++];
        McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(PixelColor); /* paint pixel */
        FirstRead = FALSE;
      } else {
        uint16_t LastPixel = PixelColor; /* save data of last pixel (word format) to temporary variable */

        PixelColor = (McuGDisplay_PixelColor)bmp[Pos++]; /* read next pixel */
        McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(PixelColor); /* paint new pixel */
        if (LastPixel == PixelColor) {  /* check if the last two read pixels are identical */
          Repeat = bmp[Pos++];          /* if yes: read number following pixels of this color */
          i += Repeat;                  /* increment pixel counter */
          while (Repeat--) {            /* output requested number of pixels */
            McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(PixelColor);
          }
          FirstRead = TRUE;             /* restart potential repetition sequence */
        }
      }
    }
  } else {
    word i;
    McuGDisplay_PixelColor pixelColor;

    for(i=0; i<pixelCount; i++) {
      pixelColor = (McuGDisplay_PixelColor)bmp[i];
      McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(pixelColor);
    }
  }
  McuGDisplay_CONFIG_FCT_NAME_CLOSEWINDOW(); /* close and execute window */
#else
  /* NYI */
  (void)x1; (void)y1; (void)x2; (void)y2; (void)bmp; (void)compressed; /* avoid compiler warning */
#endif
}

/*
** ===================================================================
**     Method      :  McuGDisplay_Draw256BitmapHigh (component GDisplay)
**     Description :
**         Draws a 256 color bitmap (compressed or uncompressed) with a
**         color table.
**     Parameters  :
**         NAME            - DESCRIPTION
**         x1              - left upper starting corner
**         y1              - left upper starting corner
**         x2              - right lower corner
**         y2              - right lower corner
**       * bmp             - Pointer to bitmap
**       * ColorTable      - Pointer to array of colors
**                           (color table)
**         compressed      - 
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_Draw256BitmapHigh(McuGDisplay_PixelDim x1, McuGDisplay_PixelDim y1, McuGDisplay_PixelDim x2, McuGDisplay_PixelDim y2, byte *bmp, McuGDisplay_PixelColor *ColorTable, bool compressed)
{
#if McuGDisplay_CONFIG_USE_WINDOW_CAPABILITY
  McuGDisplay_PixelCount pixelCount = (McuGDisplay_PixelCount)((x2-x1+1) * (y2-y1+1));

#endif
#if McuGDisplay_CONFIG_USE_WINDOW_CAPABILITY
  McuGDisplay_CONFIG_FCT_NAME_OPENWINDOW(x1, y1, x2, y2); /* set up window as large as the box */
  if (compressed) {
    byte PixelColorIndex = 0;
    uint16_t Pos = 0;
    bool FirstRead = TRUE;
    uint16_t i;
    byte LastPixelIndex;
    byte Repeat;

    for (i=0; i<pixelCount; i++) {
      if (FirstRead) {                  /* read first pixel after first start or after finishing a compressed bunch of data */
        PixelColorIndex = bmp[Pos++];
        McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(ColorTable[PixelColorIndex]);
        FirstRead = FALSE;
      } else {
        LastPixelIndex = PixelColorIndex; /* save data of last pixel (word format) to temporary variable */
        PixelColorIndex = bmp[Pos++];   /* read next pixel */
        McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(ColorTable[PixelColorIndex]);
        if (LastPixelIndex == PixelColorIndex) { /* check if the last two read pixels are identical */
          Repeat = bmp[Pos++];          /* if yes: read number following pixels of this color */
          i += Repeat;                  /* increment pixel counter */
          while (Repeat--) {            /* output requested number of pixels */
            McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(ColorTable[PixelColorIndex]);
          }
          FirstRead = TRUE;             /* restart potential repetition sequence */
        }
      }
    }
  } else {
    McuGDisplay_PixelCount i;
    uint8_t PixelColorIndex;
    uint16_t PixelColor;

    for(i=0; i<pixelCount; i++) {
      PixelColorIndex = bmp[i];
      PixelColor = ColorTable[PixelColorIndex];
      McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(PixelColor);
    }
  }
  McuGDisplay_CONFIG_FCT_NAME_CLOSEWINDOW(); /* close and execute window */
#else
  /* NYI */
  (void)x1; (void)y1; (void)x2; (void)y2; (void)bmp;  (void)ColorTable; (void)compressed; /* avoid compiler warning */
#endif
}

/*
** ===================================================================
**     Method      :  McuGDisplay_Draw256BitmapLow (component GDisplay)
**     Description :
**         Draws a 256 color bitmap (compressed or uncompressed)
**     Parameters  :
**         NAME            - DESCRIPTION
**         x1              - left upper starting corner
**         y1              - left upper starting corner
**         x2              - right lower corner
**         y2              - right lower corner
**       * bmp             - Pointer to bitmap
**         compressed      - 
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_Draw256BitmapLow(McuGDisplay_PixelDim x1, McuGDisplay_PixelDim y1, McuGDisplay_PixelDim x2, McuGDisplay_PixelDim y2, byte *bmp, bool compressed)
{
/* For uncompressed bitmap data:
      The pixels are provided in an array of 8bit pixel information (bmp[]).
      Each byte describes a pixel in 3-3-2 RBG format
   For compressed bitmap data:
      If two bytes are the same, this means that the 3rd byte contains how many times the color has to be repeated.
      Example: 10 red dots are compressed as:
        RED RED 8
 */

#if McuGDisplay_CONFIG_USE_WINDOW_CAPABILITY
  McuGDisplay_PixelCount pixelCount = (McuGDisplay_PixelCount)((x2-x1+1) * (y2-y1+1));

#endif
#if McuGDisplay_CONFIG_USE_WINDOW_CAPABILITY
  McuGDisplay_CONFIG_FCT_NAME_OPENWINDOW(x1, y1, x2, y2); /* set up window as large as the box */
  if (compressed) {
    /* compressed pixel information */
    byte pixelColor = 0;
    byte lastPixel;
    McuGDisplay_PixelCount pos = 0;
    bool first = TRUE;                  /* if we read the first time, or if we may have a new sequence */
    byte repeat;

    while(pixelCount!=0) {              /* while there are pixels to write... */
      if (first) {                      /* first pixel, or first after a compressed sequence */
        pixelColor = *bmp;              /* read pixel */
        bmp++;                          /* advance pointer to next pixel */
        McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(c332to565[pixelColor]); /* write pixel */
        pixelCount--;                   /* one more done */
        first = FALSE;                  /* reset flag */
      } else {
        lastPixel = pixelColor;         /* remember already written pixel to detect potential compressed sequence */
        pixelColor = *bmp;              /* read pixel */
        bmp++;                          /* advance pointer to next pixel */
        McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(c332to565[pixelColor]); /* write pixel */
        pixelCount--;                   /* one more done */
        if (lastPixel == pixelColor) {  /* do we have twice the same pixel? Then it this starts a compressed sequence... */
          repeat = *bmp;                /* yes! read the number of pixels to repeat */
          bmp++;                        /* next byte in stream */
          pixelCount -= repeat;         /* a bunch more will be done */
          while (repeat--) {            /* write requested amount of pixels */
            McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(c332to565[pixelColor]); /* write pixel */
          } /* while */
          first = TRUE;                 /* set flag for new sequence */
        }
      }
    }
  } else {
    /* uncompressed pixel information */
    while(pixelCount != 0) {            /* while there are pixels to write... */
      McuGDisplay_CONFIG_FCT_NAME_WRITEPIXEL(c332to565[*bmp]); /* write pixel */
      bmp++;                            /* next byte */
      pixelCount--;                     /* one more done */
    } /* for */
  }
  McuGDisplay_CONFIG_FCT_NAME_CLOSEWINDOW(); /* close and execute window */
#else
  /* NYI */
  (void)x1; (void)y1; (void)x2; (void)y2; (void)bmp; (void)compressed; /* avoid compiler warning */
#endif
}

/*
** ===================================================================
**     Method      :  McuGDisplay_UpdateRegion (component GDisplay)
**     Description :
**         Update a region of the display.
**     Parameters  :
**         NAME            - DESCRIPTION
**         x               - x coordinate
**         y               - y coordinate
**         w               - Width of the update region
**         h               - height of the update region
**     Returns     : Nothing
** ===================================================================
*/
#if 0
void McuGDisplay_UpdateRegion(McuGDisplay_PixelDim x, McuGDisplay_PixelDim y, McuGDisplay_PixelDim w, McuGDisplay_PixelDim h)
{
  /* method is implemented as macro in the header file */
}
#endif

/*
** ===================================================================
**     Method      :  McuGDisplay_GetWidth (component GDisplay)
**     Description :
**         Returns the width of the display in pixels (in x direction)
**     Parameters  : None
**     Returns     :
**         ---             - pixel count
** ===================================================================
*/
/*
McuGDisplay_PixelDim McuGDisplay_GetWidth(void)
  ** This method is implemented as macro
*/

/*
** ===================================================================
**     Method      :  McuGDisplay_GetHeight (component GDisplay)
**     Description :
**         Returns the height of the display in pixels (in y direction)
**     Parameters  : None
**     Returns     :
**         ---             - pixel count
** ===================================================================
*/
/*
McuGDisplay_PixelDim McuGDisplay_GetHeight(void)
  ** This method is implemented as macro
*/

/*
** ===================================================================
**     Method      :  McuGDisplay_GetLongerSide (component GDisplay)
**     Description :
**         Returns the size of the longer side of the display
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
/*
McuGDisplay_PixelDim McuGDisplay_GetLongerSide(void)
  ** This method is implemented as macro
*/

/*
** ===================================================================
**     Method      :  McuGDisplay_GetShorterSide (component GDisplay)
**     Description :
**         Returns the size of the shorter side of the display
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
/*
McuGDisplay_PixelDim McuGDisplay_GetShorterSide(void)
  ** This method is implemented as macro
*/

/*
** ===================================================================
**     Method      :  McuGDisplay_GetDisplay (component GDisplay)
**     Description :
**         Method used to reserve the display (for mutual exclusive
**         access)
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_GetDisplay(void)
{
  McuSharpMemoryDisplay_GetLCD();
}

/*
** ===================================================================
**     Method      :  McuGDisplay_GiveDisplay (component GDisplay)
**     Description :
**         Returns the display after having it reserved with
**         GetDisplay()
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_GiveDisplay(void)
{
  McuSharpMemoryDisplay_GiveLCD();
}

/*
** ===================================================================
**     Method      :  McuGDisplay_Init (component GDisplay)
**     Description :
**         
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void McuGDisplay_Init(void)
{
}

/* END McuGDisplay. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.5 [05.21]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
